---
sidebar_position: 1
slug: /
---

# Introduction

Canvas is a new architecture for decentralized applications, where every user interaction is a signed message exchanged over a peer-to-peer network.

We give you an easy-to-use data store, like Heroku or Postgres, where most application backends can be expressed in <50 lines of code.

Interacting with Canvas applications is free and fast, with zero gas and most effects instantly applied).

Rather than using a global network to create consensus over every interaction, Canvas applications' state is generated by combining the *effects* of signed messages using a [CRDT](https://crdt.tech/) (similar to Google Docs). Interactions are not finalized by the peer-to-peer network, although it's possible to add finality later, using networks like Filecoin or Arweave.

## Using Canvas

Each Canvas application is a unique file, or "contract", pinned to IPFS, that defines `models`, `routes`, and `actions`. Models define a database schema, routes are SQL queries that execute over the model store, and actions can write to models or query blockchains for data.

To run an application, anyone with the contract can execute `canvas run <contract.js>` from the command line. This gives you an API on port 8000 for the application. If you have peering enabled, it will also allow Canvas nodes to sync with each other over a peer-to-peer network.

From the frontend, users can log in to Canvas apps with a crypto wallet like Metamask, by signing a temporary session key stored in the browser. We give you [React hooks](https://www.npmjs.com/package/@canvas-js/hooks) to make [setting this up easy](./docs/tutorial/writing-a-canvas-frontend).

## Building a Canvas App

To get started, proceed to the tutorial to [build your first Canvas app](./docs/tutorial/writing-a-canvas-contract)!.
