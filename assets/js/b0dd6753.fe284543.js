"use strict";(self.webpackChunkcanvas_docs=self.webpackChunkcanvas_docs||[]).push([[274],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=u(t),m=o,h=d["".concat(l,".").concat(m)]||d[m]||c[m]||r;return t?a.createElement(h,s(s({ref:n},p),{},{components:t})):a.createElement(h,s({ref:n},p))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,s=new Array(r);s[0]=d;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var u=2;u<r;u++)s[u]=t[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9004:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>u});var a=t(7462),o=(t(7294),t(3905));const r={},s="Canvas React Hooks",i={unversionedId:"canvas/packages/hooks/README",id:"canvas/packages/hooks/README",title:"Canvas React Hooks",description:"Canvas provides React hooks for using Canvas in your frontend",source:"@site/docs/canvas/packages/hooks/README.md",sourceDirName:"canvas/packages/hooks",slug:"/canvas/packages/hooks/",permalink:"/docs/canvas/packages/hooks/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Custom Data Formats",permalink:"/docs/custom"},next:{title:"Canvas Command Line",permalink:"/docs/canvas/packages/cli/"}},l={},u=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"<code>&lt;Canvas /&gt;</code>",id:"canvas-",level:2},{value:"<code>useCanvas</code>",id:"usecanvas",level:2},{value:"<code>useRoute</code>",id:"useroute",level:2},{value:"<code>useSession</code>",id:"usesession",level:2}],p={toc:u};function c(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"canvas-react-hooks"},"Canvas React Hooks"),(0,o.kt)("p",null,"Canvas provides React hooks for using Canvas in your frontend\napplication."),(0,o.kt)("p",null,"The React hooks are currently developed for Ethereum-compatible\nchains, with ",(0,o.kt)("a",{parentName:"p",href:"https://docs.ethers.org/v5/"},"Ethers v5")," and\n",(0,o.kt)("a",{parentName:"p",href:"https://wagmi.sh/"},"wagmi"),"."),(0,o.kt)("h2",{id:"table-of-contents"},"Table of Contents"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#canvas"},(0,o.kt)("inlineCode",{parentName:"a"},"<Canvas />")),": configures the connection to Canvas"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#usecanvas"},(0,o.kt)("inlineCode",{parentName:"a"},"useCanvas()")),": returns the current app and user"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#useroute"},(0,o.kt)("inlineCode",{parentName:"a"},"useRoute(route, options)")),": fetches or subscribes to a route"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#usesession"},(0,o.kt)("inlineCode",{parentName:"a"},"useSession(chainImplementation, signer)")),": wraps an Ethereum signer, and exposes login(), logout(), and client.action() methods for taking actions")),(0,o.kt)("h2",{id:"canvas-"},(0,o.kt)("inlineCode",{parentName:"h2"},"<Canvas />")),(0,o.kt)("p",null,"To use the Canvas hooks, you must first wrap your application in a parent ",(0,o.kt)("inlineCode",{parentName:"p"},"Canvas")," element, which initializes state and sets an internal React context for the hooks to use. The only thing you have to pass the ",(0,o.kt)("inlineCode",{parentName:"p"},"Canvas")," element is a ",(0,o.kt)("inlineCode",{parentName:"p"},"host: string")," URL of a canvas app's HTTP API server."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'<Canvas host="http://localhost:8000">\n    <MyApp />\n</Canvas>\n')),(0,o.kt)("h2",{id:"usecanvas"},(0,o.kt)("inlineCode",{parentName:"h2"},"useCanvas")),(0,o.kt)("p",null,"You can access metadata about the host, and the application the host is serving, using the ",(0,o.kt)("inlineCode",{parentName:"p"},"useCanvas")," hook anywhere inside the parent ",(0,o.kt)("inlineCode",{parentName:"p"},"Canvas")," element."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import { useCanvas } from "@canvas-js/hooks"\n\nfunction MyApp({}) {\n    const { api, isLoading, data, error } = useCanvas()\n\n    return <div>{/* ...*/}</div>\n}\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"isLoading")," is initially ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," while the hook makes an initial HTTP request for application metadata, and then sets to ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," when either ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"error")," is non-null."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface ApplicationData {\n    cid: string\n    uri: string\n    appName: string\n    peerId: string | null\n    actions: string[]\n    routes: string[]\n    chains: Partial<Record<Chain, ChainId[]>>\n    peers: { id: string; protocols?: string[]; addresses?: string[] }[]\n    merkleRoots: Record<string, string>\n}\n\nexport function useCanvas(): {\n    isLoading: boolean\n    error: Error | null\n    data: ApplicationData | null\n}\n")),(0,o.kt)("h2",{id:"useroute"},(0,o.kt)("inlineCode",{parentName:"h2"},"useRoute")),(0,o.kt)("p",null,"You can use ",(0,o.kt)("inlineCode",{parentName:"p"},"useRoute")," to fetch/subscribe to data from your application's routes."),(0,o.kt)("p",null,"For example, to subscribe to the /posts route:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import { useRoute } from "@canvas-js/hooks"\n\nfunction MyApp({}) {\n    const { data, error, isLoading } = useRoute<{ content: string }>("/posts/:user", { user: "joel" })\n    // data: { content: string }[] | null\n    // error: Error | null\n    // isLoading: boolean\n\n    return <div>{/* ...*/}</div>\n}\n')),(0,o.kt)("p",null,"The hook will re-render every time the resulting ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," changes (compared deep equality)."),(0,o.kt)("p",null,"Use this pattern when you want the host to push data to the client. ",(0,o.kt)("strong",{parentName:"p"},"Don't")," use this pattern if the parameter values (",(0,o.kt)("inlineCode",{parentName:"p"},'{ user: "joel" }')," in the example) change often. For subscriptions, routes are bound to concrete parameter values, so changing the parameters forces the hook to unsubscribe and re-subscribe."),(0,o.kt)("p",null,"You can also provide a callback to the hook, which will be triggered whenever new data is returned from the hook. ",(0,o.kt)("strong",{parentName:"p"},"If you do this, make sure to memoize your callback (i.e. wrap it in useCallback())!")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Fetching routes without a subscription")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"useRoute")," hook can also fetch routes without subscribing to them. Pass a ",(0,o.kt)("inlineCode",{parentName:"p"},"{ subscribe: false }")," options object as the third argument and the hook will use regulular HTTP GET requests, re-fetching the route data every time any of the parameter values passed to the hook change (and only then)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import { useRoute } from "@canvas-js/hooks"\n\nfunction MyApp({}) {\n    const { data, error, isLoading } = useRoute<{ content: string }>(\n        "/posts/:user",\n        { user: "joel" },\n        { subscribe: false }\n    )\n    // data: { content: string }[] | null\n    // error: Error | null\n    // isLoading: boolean\n\n    return <div>{/* ...*/}</div>\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { ModelValue } from "@canvas-js/interfaces"\n\nexport function useRoute<T extends Record<string, ModelValue> = Record<string, ModelValue>>(\n    route: string,\n    params: Record<string, ModelValue>,\n    options: { subscribe?: boolean } = { subscribe: true }\n): { error: Error | null; isLoading: boolean; data: T[] | null }\n')),(0,o.kt)("h2",{id:"usesession"},(0,o.kt)("inlineCode",{parentName:"h2"},"useSession")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"useSession")," accepts an Ethereum signer, and returns login() and\nlogout() methods, and a client for dispatching actions."),(0,o.kt)("p",null,"For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import { useProvider, useSigner, useNetwork } from "wagmi"\nimport { EthereumChainImplementation } from "@canvas-js/ethereum"\n\nfunction MyApp({}) {\n    const provider = useProvider<ethers.providers.JsonRpcProvider>()\n    const { error, data: signer } = useSigner<ethers.providers.JsonRpcSigner>()\n    const { chain } = useNetwork()\n\n    const chainImplementation = useMemo(\n        () => new EthereumChainImplementation(chain?.id?.toString(), provider),\n        [provider, chain?.id]\n    )\n\n    const { login, logout, client } = useSession(chainImplementation, signer)\n\n    const handleSubmit = useCallback(\n        async (content: string) => {\n            if (client !== null) {\n                try {\n                    const { hash } = await client.createPost({ content })\n                    console.log("successfully posted action", hash)\n                } catch (err) {\n                    console.error(err)\n                }\n            }\n        },\n        [client]\n    )\n\n    return <div>{/* ...*/}</div>\n}\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"useSession")," hook is in one of the following three states:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"isLoading === true"),": waiting for application data from host, & checking localStorage for sessionObject"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"isLoading === false && sessionAddress === null"),": logged out, need to call login()"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"isLoading === false && sessionAddress !== null"),": we have a session and ",(0,o.kt)("inlineCode",{parentName:"li"},"client")," will be non-null")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"client"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"sessionAddress"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"sessionExpiration")," are either all null or all non-null."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { ChainImplementation, Argument } from "@canvas-js/hooks"\n\nexport type Client = Record<string, (callArgs: Record<string, ActionArgument>) => Promise<{ hash: string }>>\n\nexport function useSession<Signer, DelegatedSigner>(\n    chainImplementation: ChainImplementation<Signer, DelegatedSigner>,\n    signer: Signer | null | undefined,\n    options: { sessionDuration?: number; unchecked?: boolean } = {}\n): {\n    isLoading: boolean\n    isPending: boolean\n    sessionAddress: string | null\n    sessionExpiration: number | null\n    login: () => Promise<void>\n    logout: () => Promise<void>\n    client: Client | null\n}\n')))}c.isMDXComponent=!0}}]);