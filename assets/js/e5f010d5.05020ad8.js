"use strict";(self.webpackChunkcanvas_docs=self.webpackChunkcanvas_docs||[]).push([[145],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(n),h=r,m=d["".concat(c,".").concat(h)]||d[h]||u[h]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7437:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:4},i="Reading on-chain data",s={unversionedId:"tutorial/reading-from-chains",id:"tutorial/reading-from-chains",title:"Reading on-chain data",description:"To prevent unauthorized users from overloading the network, Canvas",source:"@site/docs/tutorial/reading-from-chains.md",sourceDirName:"tutorial",slug:"/tutorial/reading-from-chains",permalink:"/docs/tutorial/reading-from-chains",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"sidebar",previous:{title:"Connecting a frontend",permalink:"/docs/tutorial/writing-a-canvas-frontend"},next:{title:"Deploying to Fly.io & Vercel",permalink:"/docs/tutorial/deploying-to-fly-io"}},c={},l=[{value:"Referencing a smart contract",id:"referencing-a-smart-contract",level:3},{value:"Using a contract in your spec",id:"using-a-contract-in-your-spec",level:3},{value:"Running your spec",id:"running-your-spec",level:3}],p={toc:l};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"reading-on-chain-data"},"Reading on-chain data"),(0,r.kt)("p",null,"To prevent unauthorized users from overloading the network, Canvas\napplications need a way to determine who's allowed to post to the\nnetwork. This can be done using on- or off-chain identity:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"For on-chain identity, the user's identity is read from a smart\ncontract, like an identity registry or NFT contract."),(0,r.kt)("li",{parentName:"ul"},"For off-chain identity, the user should present a ",(0,r.kt)("a",{parentName:"li",href:"https://www.w3.org/TR/vc-data-model/"},"verifiable\ncredential")," or other\nproof of identity within their action, like a signed message from\na trusted address. The credential should be verified inside the\naction handler, using either hard-coded procedures, or code\nretrieved from on-chain.")),(0,r.kt)("p",null,"On-chain identity is simpler, so we'll cover that here. This tutorial\nwalks you through reading from an ERC-721 contract (an NFT)."),(0,r.kt)("h3",{id:"referencing-a-smart-contract"},"Referencing a smart contract"),(0,r.kt)("p",null,"To reference a smart contract from your spec, define it in the ",(0,r.kt)("strong",{parentName:"p"},"contracts")," export, following this format:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'export const contracts = {\n  bibos: {\n    chain: "eth",\n    chainId: 1,\n    address: "0xF528e3381372c43F5e8a55b3E6c252E32F1a26e4",\n    abi: ["function balanceOf(address owner) view returns (uint balance)"],\n  },\n};\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"name")," of the contract is how you'll reference it from within your actions."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"chain")," defines which type of chain your contract connects to. Currently, this should always be ",(0,r.kt)("inlineCode",{parentName:"li"},"eth"),", which is used for all EVM chains."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"chainId")," is the Ethereum-compatible ",(0,r.kt)("a",{parentName:"li",href:"https://chainlist.org/"},"chain ID"),"."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"address")," is the smart contract's address, as found on a block explorer like Etherscan."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"abi")," is required for Canvas to know what methods it's calling on the contract.")),(0,r.kt)("p",null,"Canvas uses ",(0,r.kt)("a",{parentName:"p",href:"https://docs.ethers.io/v5/api/utils/abi/interface/"},"Ethers v5's human-readable ABI standard"),", where each function in the ABI is described with a string. You don't have to include every function that the contract supports, ",(0,r.kt)("a",{parentName:"p",href:"https://blog.ricmoo.com/human-readable-contract-abis-in-ethers-js-141902f4d917"},"just the ones you're using"),"."),(0,r.kt)("p",null,"In our example, ",(0,r.kt)("a",{parentName:"p",href:"https://bibos.xyz/"},"Bibos")," are an ",(0,r.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-721"},"ERC-721")," compliant contract, so we use ",(0,r.kt)("inlineCode",{parentName:"p"},"balanceOf(address)")," to check the user's balance."),(0,r.kt)("h3",{id:"using-a-contract-in-your-spec"},"Using a contract in your spec"),(0,r.kt)("p",null,"Once you've exported a contract, you can use it from within your actions, using the ",(0,r.kt)("inlineCode",{parentName:"p"},"contract")," field on the action context."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'export const actions = {\n  async createPost({ content }, { db, from, hash, timestamp, contracts }) {\n    if ((await contracts.bibos.balanceOf(from)) === "0") return false;\n    db.posts.set(hash, { content, from_id: from });\n  },\n};\n')),(0,r.kt)("p",null,"The injected contract supports any method defined in its ABI, so you can use a contract that performs more advanced operations - like checking for multiple NFTs, ensuring that a balance exceeds a threshold, or even verifying a zk-proof."),(0,r.kt)("h3",{id:"running-your-spec"},"Running your spec"),(0,r.kt)("p",null,"To read the state of an on-chain contract, your local node must have access to a blockchain node. The easiest way to do this is to include an RPC endpoint of a hosted node from a provider like ",(0,r.kt)("a",{parentName:"p",href:"https://www.alchemy.com/"},"Alchemy")," or ",(0,r.kt)("a",{parentName:"p",href:"https://infura.io/"},"Infura"),". Or you can ",(0,r.kt)("a",{parentName:"p",href:"https://ethereum.org/en/developers/docs/nodes-and-clients/run-a-node/"},"set up your own node"),", but that's beyond the scope of this tutorial."),(0,r.kt)("p",null,"The first way to specify an RPC is by using the ",(0,r.kt)("strong",{parentName:"p"},"--chain-rpc")," flag, which takes three arguments, the type of chain, chain ID, and RPC URL."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"canvas run spec.canvas.js --chain-rpc eth 1 https://mainnet.infura.io/v3/[API_KEY]\n")),(0,r.kt)("p",null,"The second way is to provide it as environment variables, which you can save in a ",(0,r.kt)("strong",{parentName:"p"},".env")," file in the directory you are running your spec from. Then, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"canvas run")," as you did previously."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ETH_CHAIN_ID=1\nETH_CHAIN_RPC=https://mainnet.infura.io/v3/[API_KEY]\n")),(0,r.kt)("p",null,"You can refer to ",(0,r.kt)("a",{parentName:"p",href:"https://chainlist.org/"},"Chainlist")," for a table of common chain IDs."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Network"),(0,r.kt)("th",{parentName:"tr",align:null},"Chain ID"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Ethereum Mainnet"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Optimism (L2)"),(0,r.kt)("td",{parentName:"tr",align:null},"10")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Arbitrum (L2)"),(0,r.kt)("td",{parentName:"tr",align:null},"42161")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Gnosis (PoS)"),(0,r.kt)("td",{parentName:"tr",align:null},"100")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Polygon (PoS)"),(0,r.kt)("td",{parentName:"tr",align:null},"137")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Goerli (Testnet)"),(0,r.kt)("td",{parentName:"tr",align:null},"5")))),(0,r.kt)("p",null,"Congratulations - now you have a decentralized app where writing to the contract requires holding an NFT!"),(0,r.kt)("p",null,"Next, we will deploy both the contract and the front end so that other people can use your app as well."))}u.isMDXComponent=!0}}]);